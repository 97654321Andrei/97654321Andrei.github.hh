<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>понятие рекурсии</title>
</head>
<body>	
   <div style="position:relative;background-color: #87CEEB;width: 100% ;height: 100px;top: -15px;">
   </div>
   <div>
	<h1 style="position: relative;text-align:center;top:-110px ;">Рекурсия</h1>
	<h2 style="position: relative;text-align:center;top:-65px ;">Тема: Понятие рекурсии.</h2>
   </div> 
   	<div> 
		<ul>
			<button  style="position: relative; background-color:#87CEEB ;"><li><a href="#Понятие рекурсии."> Понятие рекурсии</a><li></button>
			<button style="position: relative; background-color:#87CEEB ;"><li><a href="#Примеры задач рекурсивного решения в текстовом и графическом режимах.
">Примеры задач рекурсивного решения в текстовом и графическом режимах.</a></li></button>
			<button style="position: relative; background-color:#87CEEB ;"><li><a href="#Косвенная рекурсия."> Косвенная рекурсия.</a></li></button>
			<button style="position: relative; background-color:#87CEEB ;"><li><a href="#Решение задач.">Решение задач.</a></li></button>
		</ul>
	</div> <br>
<section id="Понятие рекурсии.">
	
   <div> <br> 
		<hr> <br>
<p style="position: relative;left: 3%;width: 97% ;"> Рекурсия (от латинского recursio - возвращение) - это такой способ организации вычислительного процесса, при котором процедура или функция в ходе выполнения составляющих ее операторов обращается сама к себе <br><br>

<p style="position: relative;left: 3%;width: 97% ;">Для того, чтобы такое обращение не было бесконечным, в тексте подпрограммы должно быть условие, по достижению которого дальнейшего обращения не происходит. таким образом, рекурсивное обращение может включаться только в одну из ветвей подпрограммы <br><br>

 <p style="position: relative;left: 3%;width: 97% ;">В языке Паскаль нет никаких ограничений на рекурсивные вызовы подпрограмм, необходимо только понимать, что каждый очередной рекурсивный вызов приводит к образованию новой копии локальных объектов подпрограммы и все эти копии, соответствующие цепочке активизированных и не завершенных рекурсивных вызовов, существуют независимо друг от друга <br><br>

Рекурсия достаточно широко применяется в программировании, что основано на рекурсивной природе многих математических алгоритмов. А также Вы должны знать, что любой рекурсивный алгоритм можно преобразовать в эквивалентный итеративный (то есть использующий циклические конструкции). <br><br>

В больших и сложных программах иногда приходится заменять рекурсию на итерацию. Дело в том, что рекурсия связана с многократными вызовами процедур, а это несколько менее эффективно при выполнении по сравнению с использованием циклов. Однако рекурсивные версии программ, как правило, гораздо короче и нагляднее. <br><br>

Хорошей иллюстрацией механизма рекурсии является функция для вычисления факториала натурального числа. Вспомним, что факториалом числа называется произведение всех натуральных чисел от 1 до этого числа включительно: <br><br>

N! = 1*2*3* . . . *(N-2)*(N-1)*N <br>
1! = 1 <br>
0! = 1 <br><br>

Сначала покажем обычную не рекурсивную функцию для вычисления факториала, которая реализует итеративный алгоритм вычисления:</p>

<p style="position: relative;left: 3%;width: 97% ;"></p><table width="100%" bgcolor="#E0E0E0"><tbody><tr><td><code>Program KosvRecurs;<br>Var<br>&nbsp; A : integer;<br>Function NonRecFact(N:integer) : LongInt;<br>Var<br>&nbsp; i : integer; {переменная цикла }<br>&nbsp; Res : LongInt; {результат}<br>Begin<br>&nbsp; Res := 1;<br>&nbsp; for i := 1 to N do<br>&nbsp;&nbsp;&nbsp; res := Res*i;<br>&nbsp; NonResFact := Res;<br>End;</code> <br><br>  </code></td></tr></tbody></table><u></u><p><u><b>

Вторая функция использует рекурсивные обращения, что делает ее гораздо компактнее, и основана на очевидном соотношении: <br><br>

N! = (N-1)!*N <br><br>

Иными словами, чтобы получить значение факториала от числа N, достаточно умножить на N значение факториала от предыдущего числа: <br><br> 
   Function RecFact(N:integer) : LongInt;<br>Begin<br>&nbsp; if N &lt;= 1 <br>&nbsp;&nbsp;&nbsp; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResFact := 1<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResFact := N*ResFact(N-1);<br>End; <br><br>

Полностью программа, вычисляющая факториал числа, будет выглядеть так: <br><br>
Program Rekurs;<br>Var<br>&nbsp; N : integer;<br>&nbsp; F : Longint;<br><br>Function RecFact(N:integer) : LongInt;<br>Begin<br>&nbsp; if N &lt;= 1 <br>&nbsp;&nbsp;&nbsp; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResFact := 1<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ResFact := N*ResFact(N-1);<br>End;<br><br>Begin<br>&nbsp; writeln('Введите число N &gt; ';<br>&nbsp; read(N);<br>&nbsp; F := RecFact(N);<br>&nbsp; writeln('Для числа ',N,' значение факториала равно ',F);<br>End. <br><br>

<p style="position: relative;left: 3%;width: 97% ;">После запуска программы на экран выводится запрос "Введите число N > ", затем с клавиатуры считывается введенное значение и в выражении F:=RecFact(N) вызывается функция RecFact с параметром-значением N. В подпрограмме-функции проверяется условие N<=1. Если оно выполняется, то функции ResFact присваивается значение 1 и на этом выполнение подпрограммы завершается. Если условие N<=1 не соблюдается, то выполняется вычисление произведения N*ResFact(N-1). <br><br>

Вычисление произведения носит рекурсивный характер, так как при этом осуществляется вызов функции ResFact(N-1), значение которой вычисляется, в свою очередь, через вызов функции ResFact, параметром которой также будет функция ResFact, и т.д., до тех пор пока значение формального параметра N не будет равно 1. Так как базовая часть описания рекурсивной функции ResFact определяет значение ResFact для N=1, равным единице, то рекурсивные вызовы функции ResFact больше не выполняются, а наоборот выполняется вычисление функции ResFact для чисел, возрастающих от 1 до N , причем функция ResFact всякий раз возвращает значение, равное произведению очередного числа на факториал от предыдущего числа. Последнее возвращение результата вычисления функции ResFact присвоит переменной F значение произведения всех чисел от 1 до N, т.е. факториал числа N. <br><br>

<p style="position: relative;left: 3%;width: 97% ;">Итак, при выполнении рекурсивной подпрограммы осуществляется многократный переход от некоторого текущего уровня организации алгоритма к нижнему уровню последовательно до тех пор, пока не будет получено тривиальное решение поставленной задачи. В нашем примере решение при N=1 тривиально, т.е. ResFact=1. Затем осуществляется возврат на верхний уровень с последовательным вычислением значения функции ResFact. <br><br>

Задание. Введите текст рассмотренной выше программы и запишите файл на диск под соответствующим именем, а затем откомпилируйте его. После того, как компиляция закончится успешно, задайте для просмотра в окне отладчика переменные N, F. Установите видимыми одновременно окна редактора с текстом программы и окно просмотра. Исполните программу в пошаговом режиме с заходом в функцию и пронаблюдайте за изменением значения переменной N при рекурсивных вызовах функции ResFact. <br><br>

Задание. Напишите программы, демонстрирующие выполнение рекурсивного и итеративного алгоритма для задач  </a> <br><br>  
<hr>
   </div>
    </section>
    <section id="Примеры задач рекурсивного решения в текстовом и графическом режимах.">

">
    	  <br><br>  <div style="position:relative;background-color :#00BFFF ;width: 100% ;height: 100px;top: -15px;"> 
    	
    		<h2 style="position: relative;text-align:center;top:20px ;">Тема: Примеры задач рекурсивного решения в текстовом и графическом режимах.</h2> <br><br>
    	 <div> <br>
<p style="position: relative;left: 3%;width: 97% ;"> <u>Задача 1</u>.</b> Нахождение n-го члена арифметической прогрессии </p><p>&nbsp; (an=a1+d*(n-1)-формула n-го члена арифметической прогрессии).</p><table width="100%" bgcolor="#E0E0E0"><tbody><tr><td><code>Program Progressiy;<br>Var<br>&nbsp; a1, d, k: real;<br>&nbsp; n: integer;<br><br>Function Arif (a1, d: real; n: integer): real;<br>Begin<br>&nbsp; if n = 1 <br>&nbsp;&nbsp;&nbsp; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arif := a1<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arif := Arif(a1, d, n - 1) + d;<br>End;<br><br>Begin<br>&nbsp; writeln('Задайте первый член прогрессии');<br>&nbsp; readln(a1);<br>&nbsp; writeln('Задайте разность арифметической прогрессии');<br>&nbsp; readln(d);<br>&nbsp; writeln('Арифметическая прогрессия ', Аrif(a1, d, n) : 4 : 2);<br>End.</code></td></tr></tbody></table><u></u><p><u><b>Задание</b></u><b>.</b> Составьте программу </p><blockquote><p>a) нахождения n-го члена геометрической прогрессии,<br>б) нахождения суммы членов арифметической прогрессии,<br>в) нахождения суммы членов геометрической прогрессии,<br>г) нахождения n-го члена ряда Фибоначчи.</p></blockquote><p><b><u>Задача 2</u>.</b> Вложенность квадратов.</p><table width="100%" bgcolor="#E0E0E0"><tbody><tr><td><code>Program KaparovS;<br>Uses<br>&nbsp; Crt, Graph;<br>Var<br>&nbsp; x, y, x1, y1, x2, y2, x3, y3, n, d, a, b : integer<br><br>Procedure Pic(x, y, x1, y1, x2, y2, x3, y3, n, d : integer);<br>Var<br>&nbsp; k, j : integer;<br>Begin<br>&nbsp; if n &gt;=1<br>&nbsp;&nbsp;&nbsp; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line(x, y, x1, y1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line(x1, y1, x2, y2);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line(x2, y2, x3, y3);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Line(x3, y3, x, y);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; j := x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; k := y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x := (x1-x) div 2 + x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y := (y1-y) div 2 + y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x1 := (x2-x1) div 2 + x1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y1 := (y2-y1) div 2 + y1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x2 := (x3-x2) div 2 + x2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y2 := (y3-y2) div 2 + y2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x3 := (j-x3) div 2 + x3;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y3 := (k-y3) div 2 + y3;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pic(x, y, x1, y1, x2, y2, x3, y3, n-1, d);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;<br>End;<br><br>Begin<br>&nbsp; ClrScr;<br>&nbsp; write ('Введите количество повторений: ');<br>&nbsp; readln (n);<br>&nbsp; x := 0;<br>&nbsp; y := 0;<br>&nbsp; x1:= 400;<br>&nbsp; y1 := 0;<br>&nbsp; x2:= 400;<br>&nbsp; y2 := 400;<br>&nbsp; x3:= 0;<br>&nbsp; y3 := 400;<br>&nbsp; a : Detect;<br>&nbsp; InitGraph(a, b, 'D:\TP7\BGI');<br>&nbsp; ClearDevice;<br>&nbsp; Setcolor(Green);<br>&nbsp; Pic(x, y, x1, y1, x2, y2, x3, y3, n, d);<br>&nbsp; readln;<br>&nbsp; CloseGraph;<br>End.</a> <br><br> <br><br>
   </div>
    </section>
    <section id="Косвенная рекурсия.">
    	 <hr> <br><br>
    	<div style="position:relative;background-color: #87CEEB;width: 100% ;height: 100px;top: -15px;">
       </div> <hr> 
	<h2 style="position: relative;text-align:center;top:-105px ;">Тема: Косвенная рекурсия.</h2 
        <p style="position: relative;left: 3%;width: 97% ;"><p>  Рассмотренные выше программы использовали так называемую прямую рекурсию, когда в теле некоторой процедуры содержался непосредственный вызов самой себя. В языке Паскаль допускается также и косвенная рекурсия, когда, например, процедура, процедура А вызывает процедуру В, а та, в свою очередь,- процедуру А. Длина таких цепочек вызовов может быть произвольной, однако при разработке программы необходимо тщательно следить за тем, чтобы рекурсивный алгоритм был сходимым, то есть не приводил к бесконечным взаимным вызовам подпрограмм.</p><p>Образно косвенную рекурсию можно описать так. Перед зеркалом 1 стоит зеркало 2, в котором отражается само зеркало 1. В последнем видно зеркало 2 и т.д.</p><p>Приведем пример программы, иллюстрирующей косвенные рекурсивные вызовы процедур. В этой программе процедуры Rec1 и Rec2 рекурсивно вызывают друг друга, поочередно уменьшая свои фактические параметры. Легко видеть, что обе процедуры работают с одной глобальной переменной А, которая передается в них по ссылке. Критерием завершения работы является обращение этой переменной в ноль.</p><p>Обратите внимание, что в программе необходимо предварительное определение второй процедуры Rec2, так как ее вызов встречается в процедуре Rec1, т.е. перед ее полным описанием.</p><table width="100%" bgcolor="#E0E0E0"><tbody><tr><td><code>Program KosvRecurs;<br>Var<br>&nbsp; A : integer;<br>Procedure Rec2 (Var Y:integer); Forward;<br><br>Procedure Rec1 (Var X:integer);<br>Begin<br>&nbsp; X := X-1;<br>&nbsp;&nbsp;&nbsp; if X&gt;0 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rec2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeln (X)<br>End;<br><br>Procedure Rec2 (Var Y:integer);<br>Begin<br>&nbsp; Y := Y div 2;<br>&nbsp;&nbsp;&nbsp; if Y&gt;2 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Rec1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; writeln (Y)<br>End;<br><br>Begin<br>&nbsp; A := 15;<br>&nbsp; Rec1(A);<br>End. <br><br>
    	<br><br>
    </section>
    <section id="Решение задач.">
    	<div style="position:relative;background-color: #87CEEB;width: 100% ;height: 100px;top: -15px;">   <hr> 
    		 <br><br> <br><br>  <h2 style="position: relative;text-align:center;top:-50px ;">Тема: Решение задач.</h2> <br><br> <br><br>
    	<p style="position: relative;left: 3%;width: 97% ;"> <li><p> <li> <br><br> Определите члены последовательность Фибоначчи.</li><br><br><li>Найдите максимальный элемент в одномерном массиве.</li><br><br><li>Составьте алгоритм вычисления суммы <br>.<br><u>Указание</u>. Обозначьте  и используйте соотношения<br></li><br><br><li>Вычислите <br></li><br><br><li>Определите n-й член последовательности, в которой каждый следующий член равен сумме обратных величин всех предыдущих.</li><br><br><li>Определите n-й член последовательности, в которой каждый следующий член равен сумме квадратов всех предыдущих.</li><br><br><li>При положительном а решением уравнения х=х/2+а/(2х) служит х=√<span style="text-decoration: overline">a</span>. Рекуррентное соотношение <br> можно использовать для быстрого вычисления √<span style="text-decoration: overline">a</span>. Определите корень квадратный числа а.</li><br><br><li>Составьте алгоритм для вычисления <sup>3</sup>√<span style="text-decoration: overline">a</span>, используя соотношение <br></li><br><br><li>Составьте алгоритм, вычисляющий n-й член последовательности, заданной соотношениями:<br></li><br><br><li>Составить рекурсивную программу ввода с клавиатуры последовательности чисел (окончание ввода - 0) и вывода ее на экран в обратном порядке.</li></ol><p>Для сдачи зачета приготовьте файлы и листинги с решенными задачами, а также будьте готовы ответить на теоретические вопросы, рассмотренные в этой теме. </p><h1>Для любознательных</h1><h1>Ханойские башни. Задача о разрезании прямоугольника</h1><p>Ханойские башни - это древняя игра. Заключается она в следующем. Имеются три стержня, на одном из них (например, на правом) насажены диски разных размеров, причем диски располагаются так, чтобы стержень с дисками напоминал башню, т.е. внизу располагаются самые большие диски, а вверху - маленькие. Цель игры - перенести башню с правого стержня на левый, причем за один раз можно переносить только один диск и при этом можно насаживать только диск с меньшим диаметром на диск с большим диаметром. Средний стержень является вспомогательным для временного хранения дисков.</p><p>В программе применяются вложенность подпрограмм и рекурсивный вызов подпрограмм.</p><p>Пронумеруем стержни слева направо и договоримся переносить диски с правого (3) стержня на левый(1).</p><table width="100%" bgcolor="#E0E0E0"><tbody><tr><td><code>Program Tower;<br>Type<br>&nbsp; Position = (Left, Centre, Right);<br>Var<br>&nbsp; N : integer;<br><br>Procedure MoveDisk (From, Tol : Position);<br>Procedure writePos (P : Position);<br>Begin<br>&nbsp; case P of<br>&nbsp;&nbsp;&nbsp; Left : write ('1');<br>&nbsp;&nbsp;&nbsp; Centre : write ('2');<br>&nbsp;&nbsp;&nbsp; Right : write ('3');<br>&nbsp; end;<br>End;<br>Begin <br>&nbsp; writePos (From);<br>&nbsp; write('-&gt;');<br>&nbsp; writePos (Tol);<br>&nbsp; writeln<br>End;<br><br>Procedure MoveTower(Hight : integer; From, Tol, Work : Position);<br>Begin<br>&nbsp; if Hight&gt;0<br>&nbsp;&nbsp;&nbsp; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; begin<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveTower(Hight-1, From, Work, Tol);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveDisk (From, Tol);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MoveTower(Hight-1, Work, Tol, From);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;<br>End;<br><br>Begin<br>&nbsp; writeln('Введите количество колец ');<br>&nbsp; readln(N);<br>&nbsp; MoveTower(N, Right, Left, Centre);<br>End.</code></td></tr></tbody></table><p><u><b>Задание</b></u>. Изучите текст программы. Введите текст программы, запишите файл на диск и откомпилируйте его. после того, как компиляция выполнится успешно, задайте для просмотра в окне отладчика переменные Hight, From, Tol, Work. Установите видимыми одновременно окно редактора с текстом программы и окно просмотра. Исполните программу в пошаговом режиме с заходом в процедуры и пронаблюдайте за рекурсивным вызовом процедуры MoveTower. Дополните программу операторами графического режима, чтобы наглядно можно было представить перенос дисков со стержня на стержень. Дополните текст программы комментариями.</p><p>Рассмотрим задачу о разрезании прямоугольника.</p><p><u><b>Задача</b></u>. Дан прямоугольник со сторонами А и В, где А, В - натуральные числа. Начинаем отсекать от него квадраты. Сколько таких квадратов можно отсечь, если каждый раз отсекается самый большой квадрат?</p><p></p><p>Для решения этой задачи нам нужны будут функции Max и Min для переопределения длины и ширины прямоугольника. А также введем вспомогательные переменные Х и У (У&gt;=Х), соответствующие уменьшающимся сторонам прямоугольника, и вспомогательную переменную D, которая определяет уменьшение размеров прямоугольника после очередного отсечения наибольшего квадрата, сторона которого находится как Х:=Min(D, X) и продолжаем цикл.</p><p>В программе нам нужно организовать цикл, в котором сторона У уменьшается каждый раз на Min(D, X) до тех пор, пока не останется последний квадрат или У не станет меньше Х. В последнем случае переименовываем стороны оставшегося прямоугольника как Y := Max(D, X) и X := Min(D, Х) и продолжаем цикл.</p><table width="100%" bgcolor="#E0E0E0"><tbody><tr><td><code>Program OtsehKvadr;<br>Var<br>&nbsp; A, B, D, K, X, Y : integer;<br><br>Function Min(I,J : integer) : integer;<br>Begin<br>&nbsp; If I&lt;J<br>&nbsp;&nbsp;&nbsp; Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Min := I<br>&nbsp;&nbsp;&nbsp; Else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Min := J;<br>End;<br><br>Function Max(I,J : integer) : integer;<br>Begin<br>&nbsp; if I&gt;J<br>&nbsp;&nbsp;&nbsp; then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Max := I<br>&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Max := J;<br>End;<br><br>Begin<br>&nbsp; repeat<br>&nbsp;&nbsp;&nbsp; writeln ('Введите два натуральных числа ');<br>&nbsp;&nbsp;&nbsp; readln(A,B);<br>&nbsp; until (A&gt;0) and (B&gt;0);<br>&nbsp; K := 1;<br>&nbsp; X := Min(A, B);<br>&nbsp; Y := Max(A, B);<br>&nbsp; while X&lt;&gt;Y do<br>&nbsp;&nbsp;&nbsp; begin<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; K := K+1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D := Y-X;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Y := Max(D, X);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; X := Min(D, X);<br>&nbsp;&nbsp;&nbsp; end;<br>&nbsp; writeln('Искомое число квадратов : ',K);<br>End.</code></td></tr></tbody></table><p><u><b>Задание</b></u>. Наберите текст программы. Проверьте ее работоспособность. Дополните программу комментариями. Если у Вас возникло желание, то усовершенствуйте эту программу своими дополнениями. Результат покажите учителю для оценки.</p><h1>Анализ рекурсивных алгоритмов</h1><p>При изучении темы "Рекурсия" полезно проанализировать рекурсивные алгоритмы с точки зрения последовательности их выполнения. Под последовательностью выполненного рекурсивного алгоритма будем понимать последовательность вызовов алгоритма с различными значениями аргументов и очередью определения результатов. </p><p>Рассмотрим сначала функцию расчетов факториала числа (см. выше) </p><p>Для алгоритма определения 5-го члена ряда Фибоначчи схема нахождения изображена на рисунке:</p><p>Чтобы определить значение 5-го элемента Фибоначчи, для этого необходимо определить значения fib(2), fib (1), fib (3), fib (2). Из схемы видно также , что в рассматриваемом случае значения fib (1), fib (3), fib (2) определяются дважды. При нахождении члена последовательности с большим номером число повторных вычислений значительно увеличивается. В результате при определения значения fib (17) компьютер выполнит свыше 1000, значения fib (31) свыше 1000000, значения fib (45) свыше 1000000000 операций сложения. В тоже время при использовании не рекурсивного алгоритма для вычисления 45-го члена потребуется всего 43 операции сложения.</p><p>Это позволяет сделать вывод о неэффективности использования рекурсии для решения рассматриваемой задачи. Аналогичный вывод можно сделать для решения других задач.</p><h1>Особенности отладки и компиляции программ, содержащих процедуры и функции</h1><p>При пошаговой отладке программ, содержащих процедуры и функции, при нажатии клавиши F7 в строке, которая содержит вызов подпрограммы, мы переходим в начало (на слово begin) данной подпрограммы. При завершении работы подпрограммы - если подсвечена конечная строка end или exit. При следующем нажатии F7 мы возвращаемся в ту строку основной программы, с которой попали в подпрограмму. Постоянный заход в подпрограммы часто бывает не нужен. Для пошагового исполнения основной программы без захода в подпрограммы используйте клавишу F8.</p><p>В меню Debug предусмотрено специальное окно для просмотра последовательности вызываемых функций и процедур. Это окно открывается клавишами Ctrl+F4 или через пункт меню Debug/Call stack. В этом окне прослеживается текущее, то есть изменяющееся при пошаговой отладке, состояние стека вызова подпрограмм. В верхней строке - исполняемая в данный момент подпрограмма, в нижней - основная программа, в промежутке между ними - последовательность вызовов подпрограмм от основной программы до текущей программы. </p><p>При выходе из подпрограммы стек программы освобождается от ее вызова, и верхняя строка в окне стека убирается. Это окно следует применять при сложной иерархии взаимных вызовов подпрограмм, когда не очевидно, каким путем выполнение алгоритма привело к данной подпрограмме.</p><p>При разработке программных проектов, содержащих несколько модулей, удобно использовать многооконный интерфейс среды, позволяющий одновременно работать со всеми файлами данного проекта. </p><p>Пункты этого меню позволяют выбрать расположение окон на экране, переключаться между окнами, закрывать окна. Пункт Tile разделяет экран на отдельные кусочки, в каждом из которых находится свое окно. Такой способ разбиения имеет смысл применить, если открыто 2-4 окна. Пункт Cascade накладывает окна одно на другое таким образом, что край нижних окон виден из-под верхних. При таком раскладе окон каждое из них имеет достаточно большой размер и легко может быть активизировано.</p><p>Переключение между окнами производится нажатием клавиш, указанными в меню. Для изменения размера и положения окна нужно нажатием клавиш Ctrl+F5 вызвать пункт Size/Move. Размеры окна изменяются клавишами перемещения курсора. Когда требуемый размер установлен, нужно нажать Enter для фиксации положения окна. Если Вы забудете нажать Enter, все действия будут блокированы. Для перемещения окна при нажатии клавиш управления курсором надо держать нажатой клавишу Shift.</p><p>При компиляции проектов, использующих модули, можно использовать различные режимы компиляции.</p><p>По нажатию клавиш Alt+F9 компилируется программа или модуль, находившиеся в активном окне. Используемые этой программой модули должны быть предварительно откомпилированы.</p><p>Компиляцию проектов, состоящих из нескольких модулей, удобно производить, установив основной файл - это, как правило, файл с основной программой. Для этого выбирается пункт Primary file и вводится имя файла. Уничтожение этой записи производится путем выбора пункта Clear primary file. Если начальный файл установлен, компиляция или компиляция с исполнением происходит всегда так, как будто активным окном являлось окно основной программы. Это позволяет вносить изменения в отдельных модулях и сразу запускать компиляцию и исполнение всего проекта, не переключаясь специально к основной программе.</p><p>Для подключения к основной программе модулей компилятор ищет их прежде всего в рабочем каталоге, а затем в каталогах, указанных в строке Units окна настройки, которое появляется при выборе пункта меню Options/Directories.</p><p>При нажатии клавиши F9 (Make) прежде всего происходит компиляция начального файла, заданного в строке Primary file. Если эта строка пуста, компиляция начинается с активного окна. когда в процессе компиляции программы или модуля встречаются ссылки на другие модули, проверяется необходимость перекомпиляции подключаемых модулей. Проверка заключается в сверке изменений файла с текстом модуля на Паскале и откомпилированного модуля (по времени внесения последних изменений в файл). Если в текст были внесены изменения, данный модуль компилируется вновь. Если файл модуля с текстом не найден , берется откомпилированный файл без проверки. Эта опция компилятора оптимальна по затратам времени на компиляцию, так как компилируется только то, что нужно. Компиляция и запуск на исполнение, вызываемые клавишами Ctrl+F9, производит компиляцию по данной логике.</p><p>В ряде случаев нам необходима обязательная перекомпиляция всех файлов (Build). В частности, это необходимо, если мы изменили опции компиляции в меню Options/Compiler. Изменение опций компиляции через окно не прослеживается далее автоматически, то есть среда не определяет, откомпилирован файл с новыми или старыми опциями, и не производит автоматически перекомпиляцию. Для полной компиляции всех файлов вызывается пункт Build.</p><p>Пункт Target устанавливает, для какой платформы - реального режима, защищенного режима или Windows - должны компилироваться файлы  <br><br>   <hr>
</body>
</html>
<div>
	Кудлаев Андрей Сергеевич</p>
      <p>Адрес: Кыргызыстан, Г,Бишкек, Ул, Краснодарская 25/12.</p>
      <p>Emfil <a href="#0">nricolista@gmail.com</a></a>
      <p>Тел: +996-706-322-541</p>
      <a style="position: relative;47%" href="https://vk.com/id435931041"></big>
</div>